<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Writing R extensions</title>
  <meta name="description" content="Writing R Extensions covers how to create your own packages, write R help files, and the foreign language (C, C++, Fortran, …) interfaces.">
  <meta name="generator" content="bookdown 0.5 and GitBook 2.6.7">

  <meta property="og:title" content="Writing R extensions" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Writing R Extensions covers how to create your own packages, write R help files, and the foreign language (C, C++, Fortran, …) interfaces." />
  <meta name="github-repo" content="ColinFay/writing-r-extensions" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Writing R extensions" />
  
  <meta name="twitter:description" content="Writing R Extensions covers how to create your own packages, write R help files, and the foreign language (C, C++, Fortran, …) interfaces." />
  

<meta name="author" content="R Development Core Team">


<meta name="date" content="2017-10-10">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="tidying-and-profiling-r-code.html">
<link rel="next" href="system-and-foreign-language-interfaces.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-65307055-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-65307055-1');
</script>



<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Writing R Extensions</a></li>
<li class="chapter" data-level="" data-path="acknowledgements.html"><a href="acknowledgements.html"><i class="fa fa-check"></i>Acknowledgements</a></li>
<li class="chapter" data-level="1" data-path="creating-r-packages.html"><a href="creating-r-packages.html"><i class="fa fa-check"></i><b>1</b> Creating R packages</a></li>
<li class="chapter" data-level="2" data-path="writing-r-documentation-files.html"><a href="writing-r-documentation-files.html"><i class="fa fa-check"></i><b>2</b> Writing R documentation files</a></li>
<li class="chapter" data-level="3" data-path="tidying-and-profiling-r-code.html"><a href="tidying-and-profiling-r-code.html"><i class="fa fa-check"></i><b>3</b> Tidying and profiling R code</a></li>
<li class="chapter" data-level="4" data-path="debugging.html"><a href="debugging.html"><i class="fa fa-check"></i><b>4</b> Debugging</a></li>
<li class="chapter" data-level="5" data-path="system-and-foreign-language-interfaces.html"><a href="system-and-foreign-language-interfaces.html"><i class="fa fa-check"></i><b>5</b> System and foreign language interfaces</a></li>
<li class="chapter" data-level="6" data-path="the-r-api-entry-points-for-c-code.html"><a href="the-r-api-entry-points-for-c-code.html"><i class="fa fa-check"></i><b>6</b> The R API: entry points for C code</a></li>
<li class="chapter" data-level="7" data-path="generic-functions-and-methods.html"><a href="generic-functions-and-methods.html"><i class="fa fa-check"></i><b>7</b> Generic functions and methods</a></li>
<li class="chapter" data-level="8" data-path="linking-guis-and-other-front-ends-to-r.html"><a href="linking-guis-and-other-front-ends-to-r.html"><i class="fa fa-check"></i><b>8</b> Linking GUIs and other front-ends to R</a></li>
<li class="chapter" data-level="9" data-path="function-and-variable-index.html"><a href="function-and-variable-index.html"><i class="fa fa-check"></i><b>9</b> Function and variable index</a></li>
<li class="chapter" data-level="10" data-path="concept-index.html"><a href="concept-index.html"><i class="fa fa-check"></i><b>10</b> Concept index</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Writing R extensions</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="debugging" class="section level1">
<h1><span class="header-section-number">Chapter 4</span> Debugging</h1>
<p>
This chapter covers the debugging of R extensions, starting with the ways to get useful error information and moving on to how to deal with errors that crash R. For those who prefer other styles there are contributed packages such as <a href="https://CRAN.R-project.org/package=debug"><strong>debug</strong></a> on CRAN (described in an article in <a href="https://CRAN.R-project.org/doc/Rnews/Rnews_2003-3.pdf">R-News 3/3</a>). (There are notes from 2002 provided by Roger Peng at <a href="http://www.biostat.jhsph.edu/~rpeng/docs/R-debug-tools.pdf" class="uri">http://www.biostat.jhsph.edu/~rpeng/docs/R-debug-tools.pdf</a> which provide complementary examples to those given here.)
</p>
<hr />
<p>
<a href="" id="Browsing"></a> <a href="" id="Browsing-1"></a>
</p>
<h3 id="browsing" class="section">
4.1 Browsing
</h3>
<p>
<a href="" id="index-browser"></a>
</p>
<p>
Most of the R-level debugging facilities are based around the built-in browser. This can be used directly by inserting a call to <code class="calibre2">browser()</code> into the code of a function (for example, using <code class="calibre2">fix(my_function)</code> ). When code execution reaches that point in the function, control returns to the R console with a special prompt. For example
</p>
<div class="example">
<pre class="example1"><code>&gt; fix(summary.data.frame) ## insert browser() call after for() loop
&gt; summary(women)
Called from: summary.data.frame(women)
Browse[1]&gt; ls()
 [1] &quot;digits&quot; &quot;i&quot;      &quot;lbs&quot;    &quot;lw&quot;     &quot;maxsum&quot; &quot;nm&quot;     &quot;nr&quot;     &quot;nv&quot;
 [9] &quot;object&quot; &quot;sms&quot;    &quot;z&quot;
Browse[1]&gt; maxsum
[1] 7
Browse[1]&gt;
     height         weight
 Min.   :58.0   Min.   :115.0
 1st Qu.:61.5   1st Qu.:124.5
 Median :65.0   Median :135.0
 Mean   :65.0   Mean   :136.7
 3rd Qu.:68.5   3rd Qu.:148.0
 Max.   :72.0   Max.   :164.0
&gt; rm(summary.data.frame)</code></pre>
</div>
<p>
At the browser prompt one can enter any R expression, so for example <code class="calibre2">ls()</code> lists the objects in the current frame, and entering the name of an object will<a href="concept-index.html#FOOT103" id="DOCF103"><sup>103</sup></a> print it. The following commands are also accepted
</p>
<ul>
<li>
<p>
<code class="calibre2">n</code>
</p>
<p>
Enter ‘step-through’ mode. In this mode, hitting return executes the next line of code (more precisely one line and any continuation lines). Typing <code class="calibre2">c</code> will continue to the end of the current context, e.g. to the end of the current loop or function.
</p>
</li>
<li>
<p>
<code class="calibre2">c</code>
</p>
<p>
In normal mode, this quits the browser and continues execution, and just return works in the same way. <code class="calibre2">cont</code> is a synonym.
</p>
</li>
<li>
<p>
<code class="calibre2">where</code>
</p>
<p>
This prints the call stack. For example
</p>
<div class="example">
<pre class="example1"><code>&gt; summary(women)
Called from: summary.data.frame(women)
Browse[1]&gt; where
where 1: summary.data.frame(women)
where 2: summary(women)

Browse[1]&gt;</code></pre>
</div>
</li>
<li>
<p>
<code class="calibre2">Q</code>
</p>
<p>
Quit both the browser and the current expression, and return to the top-level prompt.
</p>
</li>
</ul>
<p>
Errors in code executed at the browser prompt will normally return control to the browser prompt. Objects can be altered by assignment, and will keep their changed values when the browser is exited. If really necessary, objects can be assigned to the workspace from the browser prompt (by using <code class="calibre2">&lt;&lt;-</code> if the name is not already in scope).
</p>
<hr />
<p>
<a href="" id="Debugging-R-code"></a> <a href="" id="Debugging-R-code-1"></a>
</p>
<h3 id="debugging-r-code" class="section">
4.2 Debugging R code
</h3>
<p>
<a href="" id="index-traceback"></a>
</p>
<p>
Suppose your R program gives an error message. The first thing to find out is what R was doing at the time of the error, and the most useful tool is <code class="calibre2">traceback()</code>. We suggest that this is run whenever the cause of the error is not immediately obvious. Daily, errors are reported to the R mailing lists as being in some package when <code class="calibre2">traceback()</code> would show that the error was being reported by some other package or base R. Here is an example from the regression suite.
</p>
<div class="example">
<pre class="smallexample"><code>&gt; success &lt;- c(13,12,11,14,14,11,13,11,12)
&gt; failure &lt;- c(0,0,0,0,0,0,0,2,2)
&gt; resp &lt;- cbind(success, failure)
&gt; predictor &lt;- c(0, 5^(0:7))
&gt; glm(resp ~ 0+predictor, family = binomial(link=&quot;log&quot;))
Error: no valid set of coefficients has been found: please supply starting values
&gt; traceback()
3: stop(&quot;no valid set of coefficients has been found: please supply
         starting values&quot;, call. = FALSE)
2: glm.fit(x = X, y = Y, weights = weights, start = start, etastart = etastart,
       mustart = mustart, offset = offset, family = family, control = control,
       intercept = attr(mt, &quot;intercept&quot;) &gt; 0)
1: glm(resp ~ 0 + predictor, family = binomial(link =&quot;log&quot;))</code></pre>
</div>
<p>
The calls to the active frames are given in reverse order (starting with the innermost). So we see the error message comes from an explicit check in <code class="calibre2">glm.fit</code>. (<code class="calibre2">traceback()</code> shows you all the lines of the function calls, which can be limited by setting <code class="calibre2">option</code> “deparse.max.lines”.)
</p>
<p>
Sometimes the traceback will indicate that the error was detected inside compiled code, for example (from <code class="calibre2">?nls</code>)
</p>
<div class="example">
<pre class="smallexample"><code>Error in nls(y ~ a + b * x, start = list(a = 0.12345, b = 0.54321), trace = TRUE) :
        step factor 0.000488281 reduced below ‘minFactor’ of 0.000976563
&gt;  traceback()
2: .Call(R_nls_iter, m, ctrl, trace)
1: nls(y ~ a + b * x, start = list(a = 0.12345, b = 0.54321), trace = TRUE)</code></pre>
</div>
<p>
This will be the case if the innermost call is to <code class="calibre2">.C</code>, <code class="calibre2">.Fortran</code>, <code class="calibre2">.Call</code>, <code class="calibre2">.External</code> or <code class="calibre2">.Internal</code>, but as it is also possible for such code to evaluate R expressions, this need not be the innermost call, as in
</p>
<div class="example">
<pre class="smallexample"><code>&gt; traceback()
9: gm(a, b, x)
8: .Call(R_numeric_deriv, expr, theta, rho, dir)
7: numericDeriv(form[[3]], names(ind), env)
6: getRHS()
5: assign(&quot;rhs&quot;, getRHS(), envir = thisEnv)
4: assign(&quot;resid&quot;, .swts * (lhs - assign(&quot;rhs&quot;, getRHS(), envir = thisEnv)),
       envir = thisEnv)
3: function (newPars)
   {
       setPars(newPars)
       assign(&quot;resid&quot;, .swts * (lhs - assign(&quot;rhs&quot;, getRHS(), envir = thisEnv)),
           envir = thisEnv)
       assign(&quot;dev&quot;, sum(resid^2), envir = thisEnv)
       assign(&quot;QR&quot;, qr(.swts * attr(rhs, &quot;gradient&quot;)), envir = thisEnv)
       return(QR$rank &lt; min(dim(QR$qr)))
   }(c(-0.00760232418963883, 1.00119632515036))
2: .Call(R_nls_iter, m, ctrl, trace)
1: nls(yeps ~ gm(a, b, x), start = list(a = 0.12345, b = 0.54321))</code></pre>
</div>
<p>
Occasionally <code class="calibre2">traceback()</code> does not help, and this can be the case if S4 method dispatch is involved. Consider the following example
</p>
<div class="example">
<pre class="example1"><code>&gt; xyd &lt;- new(&quot;xyloc&quot;, x=runif(20), y=runif(20))
Error in as.environment(pkg) : no item called &quot;package:S4nswv&quot;
on the search list
Error in initialize(value, ...) : S language method selection got
an error when called from internal dispatch for function ‘initialize’
&gt; traceback()
2: initialize(value, ...)
1: new(&quot;xyloc&quot;, x = runif(20), y = runif(20))</code></pre>
</div>
<p>
which does not help much, as there is no call to <code class="calibre2">as.environment</code> in <code class="calibre2">initialize</code> (and the note “called from internal dispatch” tells us so). In this case we searched the R sources for the quoted call, which occurred in only one place, <code class="calibre2">methods:::.asEnvironmentPackage</code>. So now we knew where the error was occurring. (This was an unusually opaque example.)
</p>
<p>
The error message
</p>
<div class="example">
<pre class="example1"><code>evaluation nested too deeply: infinite recursion / options(expressions=)?</code></pre>
</div>
<p>
can be hard to handle with the default value (5000). Unless you know that there actually is deep recursion going on, it can help to set something like
</p>
<div class="example">
<pre class="example1"><code>options(expressions=500)</code></pre>
</div>
<p>
and re-run the example showing the error.
</p>
<p>
Sometimes there is warning that clearly is the precursor to some later error, but it is not obvious where it is coming from. Setting <code class="calibre2">options(warn = 2)</code> (which turns warnings into errors) can help here.
</p>
<p>
Once we have located the error, we have some choices. One way to proceed is to find out more about what was happening at the time of the crash by looking a <em>post-mortem</em> dump. To do so, set <a href="" id="index-dump_002eframes"></a> <code class="calibre2">options(error=dump.frames)</code> and run the code again. Then invoke <code class="calibre2">debugger()</code> and explore the dump. Continuing our example:
</p>
<div class="example">
<pre class="smallexample"><code>&gt; options(error = dump.frames)
&gt; glm(resp ~ 0 + predictor, family = binomial(link =&quot;log&quot;))
Error: no valid set of coefficients has been found: please supply starting values</code></pre>
</div>
<p>
which is the same as before, but an object called <code class="calibre2">last.dump</code> has appeared in the workspace. (Such objects can be large, so remove it when it is no longer needed.) We can examine this at a later time by calling the function <code class="calibre2">debugger</code>. <a href="" id="index-debugger"></a>
</p>
<div class="example">
<pre class="smallexample"><code>&gt; debugger()
Message:  Error: no valid set of coefficients has been found: please supply starting values
Available environments had calls:
1: glm(resp ~ 0 + predictor, family = binomial(link = &quot;log&quot;))
2: glm.fit(x = X, y = Y, weights = weights, start = start, etastart = etastart, mus
3: stop(&quot;no valid set of coefficients has been found: please supply starting values
Enter an environment number, or 0 to exit  Selection:</code></pre>
</div>
<p>
which gives the same sequence of calls as <code class="calibre2">traceback</code>, but in outer-first order and with only the first line of the call, truncated to the current width. However, we can now examine in more detail what was happening at the time of the error. Selecting an environment opens the browser in that frame. So we select the function call which spawned the error message, and explore some of the variables (and execute two function calls).
</p>
<div class="example">
<pre class="smallexample"><code>Enter an environment number, or 0 to exit  Selection: 2
Browsing in the environment with call:
   glm.fit(x = X, y = Y, weights = weights, start = start, etas
Called from: debugger.look(ind)
Browse[1]&gt; ls()
 [1] &quot;aic&quot;        &quot;boundary&quot;   &quot;coefold&quot;    &quot;control&quot;    &quot;conv&quot;
 [6] &quot;dev&quot;        &quot;dev.resids&quot; &quot;devold&quot;     &quot;EMPTY&quot;      &quot;eta&quot;
[11] &quot;etastart&quot;   &quot;family&quot;     &quot;fit&quot;        &quot;good&quot;       &quot;intercept&quot;
[16] &quot;iter&quot;       &quot;linkinv&quot;    &quot;mu&quot;         &quot;mu.eta&quot;     &quot;mu.eta.val&quot;
[21] &quot;mustart&quot;    &quot;n&quot;          &quot;ngoodobs&quot;   &quot;nobs&quot;       &quot;nvars&quot;
[26] &quot;offset&quot;     &quot;start&quot;      &quot;valideta&quot;   &quot;validmu&quot;    &quot;variance&quot;
[31] &quot;varmu&quot;      &quot;w&quot;          &quot;weights&quot;    &quot;x&quot;          &quot;xnames&quot;
[36] &quot;y&quot;          &quot;ynames&quot;     &quot;z&quot;
Browse[1]&gt; eta
            1             2             3             4             5
 0.000000e+00 -2.235357e-06 -1.117679e-05 -5.588393e-05 -2.794197e-04
            6             7             8             9
-1.397098e-03 -6.985492e-03 -3.492746e-02 -1.746373e-01
Browse[1]&gt; valideta(eta)
[1] TRUE
Browse[1]&gt; mu
        1         2         3         4         5         6         7         8
1.0000000 0.9999978 0.9999888 0.9999441 0.9997206 0.9986039 0.9930389 0.9656755
        9
.8397616
Browse[1]&gt; validmu(mu)
[1] FALSE
Browse[1]&gt; c
Available environments had calls:
1: glm(resp ~ 0 + predictor, family = binomial(link = &quot;log&quot;))
2: glm.fit(x = X, y = Y, weights = weights, start = start, etastart = etastart
3: stop(&quot;no valid set of coefficients has been found: please supply starting v

Enter an environment number, or 0 to exit  Selection: 0
&gt; rm(last.dump)</code></pre>
</div>
<p>
Because <code class="calibre2">last.dump</code> can be looked at later or even in another R session, post-mortem debugging is possible even for batch usage of R. We do need to arrange for the dump to be saved: this can be done either using the command-line flag –save to save the workspace at the end of the run, or <em>via</em> a setting such as
</p>
<div class="example">
<pre class="example1"><code>&gt; options(error = quote({dump.frames(to.file=TRUE); q()}))</code></pre>
</div>
<p>
See the help on <code class="calibre2">dump.frames</code> for further options and a worked example.
</p>
<p>
<a href="" id="index-recover"></a>
</p>
<p>
An alternative error action is to use the function <code class="calibre2">recover()</code>:
</p>
<div class="example">
<pre class="smallexample"><code>&gt; options(error = recover)
&gt; glm(resp ~ 0 + predictor, family = binomial(link = &quot;log&quot;))
Error: no valid set of coefficients has been found: please supply starting values

Enter a frame number, or 0 to exit

1: glm(resp ~ 0 + predictor, family = binomial(link = &quot;log&quot;))
2: glm.fit(x = X, y = Y, weights = weights, start = start, etastart = etastart

Selection:</code></pre>
</div>
<p>
which is very similar to <code class="calibre2">dump.frames</code>. However, we can examine the state of the program directly, without dumping and re-loading the dump. As its help page says, <code class="calibre2">recover</code> can be routinely used as the error action in place of <code class="calibre2">dump.calls</code> and <code class="calibre2">dump.frames</code>, since it behaves like <code class="calibre2">dump.frames</code> in non-interactive use.
</p>
<p>
<a href="" id="index-debug"></a>
</p>
<p>
Post-mortem debugging is good for finding out exactly what went wrong, but not necessarily why. An alternative approach is to take a closer look at what was happening just before the error, and a good way to do that is to use <code class="calibre2">debug</code>. This inserts a call to the browser at the beginning of the function, starting in step-through mode. So in our example we could use
</p>
<div class="example">
<pre class="smallexample"><code>&gt; debug(glm.fit)
&gt; glm(resp ~ 0 + predictor, family = binomial(link =&quot;log&quot;))
debugging in: glm.fit(x = X, y = Y, weights = weights, start = start, etastart = etastart,
    mustart = mustart, offset = offset, family = family, control = control,
    intercept = attr(mt, &quot;intercept&quot;) &gt; 0)
debug: {
## lists the whole function
Browse[1]&gt;
debug: x &lt;- as.matrix(x)
...
Browse[1]&gt; start
[1] -2.235357e-06
debug: eta &lt;- drop(x %*% start)
Browse[1]&gt; eta
            1             2             3             4             5
 0.000000e+00 -2.235357e-06 -1.117679e-05 -5.588393e-05 -2.794197e-04
            6             7             8             9
-1.397098e-03 -6.985492e-03 -3.492746e-02 -1.746373e-01
Browse[1]&gt;
debug: mu &lt;- linkinv(eta &lt;- eta + offset)
Browse[1]&gt; mu
        1         2         3         4         5         6         7         8
1.0000000 0.9999978 0.9999888 0.9999441 0.9997206 0.9986039 0.9930389 0.9656755
        9
.8397616</code></pre>
</div>
<p>
(The prompt <code class="calibre2">Browse[1]&gt;</code> indicates that this is the first level of browsing: it is possible to step into another function that is itself being debugged or contains a call to <code class="calibre2">browser()</code>.)
</p>
<p>
<code class="calibre2">debug</code> can be used for hidden functions and S3 methods by e.g. <code class="calibre2">debug(stats:::predict.Arima)</code>. (It cannot be used for S4 methods, but an alternative is given on the help page for <code class="calibre2">debug</code>.) Sometimes you want to debug a function defined inside another function, e.g. the function <code class="calibre2">arimafn</code> defined inside <code class="calibre2">arima</code>. To do so, set <code class="calibre2">debug</code> on the outer function (here <code class="calibre2">arima</code>) and step through it until the inner function has been defined. Then call <code class="calibre2">debug</code> on the inner function (and use <code class="calibre2">c</code> to get out of step-through mode in the outer function).
</p>
<p>
<a href="" id="index-undebug"></a>
</p>
<p>
To remove debugging of a function, call <code class="calibre2">undebug</code> with the argument previously given to <code class="calibre2">debug</code>; debugging otherwise lasts for the rest of the R session (or until the function is edited or otherwise replaced).
</p>
<p>
<a href="" id="index-trace"></a>
</p>
<p>
<code class="calibre2">trace</code> can be used to temporarily insert debugging code into a function, for example to insert a call to <code class="calibre2">browser()</code> just before the point of the error. To return to our running example
</p>
<div class="example">
<pre class="example1"><code>## first get a numbered listing of the expressions of the function
&gt; page(as.list(body(glm.fit)), method=&quot;print&quot;)
&gt; trace(glm.fit, browser, at=22)
Tracing function &quot;glm.fit&quot; in package &quot;stats&quot;
[1] &quot;glm.fit&quot;
&gt; glm(resp ~ 0 + predictor, family = binomial(link =&quot;log&quot;))
Tracing glm.fit(x = X, y = Y, weights = weights, start = start,
   etastart = etastart,  .... step 22
Called from: eval(expr, envir, enclos)
Browse[1]&gt; n
## and single-step from here.
&gt; untrace(glm.fit)</code></pre>
</div>
<p>
For your own functions, it may be as easy to use <code class="calibre2">fix</code> to insert temporary code, but <code class="calibre2">trace</code> can help with functions in a namespace (as can <code class="calibre2">fixInNamespace</code>). Alternatively, use <code class="calibre2">trace(,edit=TRUE)</code> to insert code visually.
</p>
<hr />
<p>
<a href="" id="Checking-memory-access"></a> <a href="" id="Checking-memory-access-1"></a>
</p>
<h3 id="checking-memory-access" class="section">
4.3 Checking memory access
</h3>
<p>
Errors in memory allocation and reading/writing outside arrays are very common causes of crashes (e.g., segfaults) on some machines. Often the crash appears long after the invalid memory access: in particular damage to the structures which R itself has allocated may only become apparent at the next garbage collection (or even at later garbage collections after objects have been deleted).
</p>
<p>
Note that memory access errors may be seen with LAPACK, BLAS, OpenMP and Java-using packages: some at least of these seem to be intentional, and some are related to passing characters to Fortran.
</p>
<p>
Some of these tools can detect mismatched allocation and deallocation. C++ programmers should note that memory allocated by <code class="calibre2">new []</code> must be freed by <code class="calibre2">delete []</code>, other uses of <code class="calibre2">new</code> by <code class="calibre2">delete</code>, and memory allocated by <code class="calibre2">malloc</code>, <code class="calibre2">calloc</code> and <code class="calibre2">realloc</code> by <code class="calibre2">free</code>. Some platforms will tolerate mismatches (perhaps with memory leaks) but others will segfault.
</p>
<hr />
<p>
<a href="" id="Using-gctorture"></a> <a href="" id="Using-gctorture-1"></a>
</p>
<h4 id="using-gctorture" class="subsection">
4.3.1 Using gctorture
</h4>
<p>
<a href="" id="index-gctorture"></a>
</p>
<p>
We can help to detect memory problems in R objects earlier by running garbage collection as often as possible. This is achieved by <code class="calibre2">gctorture(TRUE)</code>, which as described on its help page
</p>
<blockquote>
<p>
Provokes garbage collection on (nearly) every memory allocation. Intended to ferret out memory protection bugs. Also makes R run <em>very</em> slowly, unfortunately.
</p>
</blockquote>
<p>
The reference to ‘memory protection’ is to missing C-level calls to <code class="calibre2">PROTECT</code>/<code class="calibre2">UNPROTECT</code> (see <a href="system-and-foreign-language-interfaces.html#Garbage-Collection">Garbage Collection</a>) which if missing allow R objects to be garbage-collected when they are still in use. But it can also help with other memory-related errors.
</p>
<p>
Normally running under <code class="calibre2">gctorture(TRUE)</code> will just produce a crash earlier in the R program, hopefully close to the actual cause. See the next section for how to decipher such crashes.
</p>
<p>
It is possible to run all the examples, tests and vignettes covered by <code class="calibre2">R CMD check</code> under <code class="calibre2">gctorture(TRUE)</code> by using the option –use-gct.
</p>
<p>
The function <code class="calibre2">gctorture2</code> provides more refined control over the GC torture process. Its arguments <code class="calibre2">step</code>, <code class="calibre2">wait</code> and <code class="calibre2">inhibit_release</code> are documented on its help page. Environment variables can also be used at the start of the R session to turn on GC torture: <code class="calibre2">R_GCTORTURE</code> corresponds to the <code class="calibre2">step</code> argument to <code class="calibre2">gctorture2</code>, <code class="calibre2">R_GCTORTURE_WAIT</code> to <code class="calibre2">wait</code>, and <code class="calibre2">R_GCTORTURE_INHIBIT_RELEASE</code> to <code class="calibre2">inhibit_release</code>.
</p>
<p>
If R is configured with –enable-strict-barrier then a variety of tests for the integrity of the write barrier are enabled. In addition tests to help detect protect issues are enabled:
</p>
<ul>
<li>
All GCs are full GCs.
</li>
<li>
New nodes in small node pages are marked as <code class="calibre2">NEWSXP</code> on creation.
</li>
<li>
After a GC all free nodes that are not of type <code class="calibre2">NEWSXP</code> are marked as type <code class="calibre2">FREESXP</code> and their previous type is recorded.
</li>
<li>
Most calls to accessor functions check their <code class="calibre2">SEXP</code> inputs and <code class="calibre2">SEXP</code> outputs and signal an error if a <code class="calibre2">FREESXP</code> is found. The address of the node and the old type are included in the error message.
</li>
</ul>
<p>
<code class="calibre2">R CMD check –use-gct</code> can be set to use <code class="calibre2">gctorture2(n)</code> rather than <code class="calibre2">gctorture(TRUE)</code> by setting environment variable <code class="calibre2"><em>R_CHECK_GCT_N</em></code> to a positive integer value to be used as <code class="calibre2">n</code>.
</p>
<p>
Used with a debugger and with <code class="calibre2">gctorture</code> or <code class="calibre2">gctorture2</code> this mechanism can be helpful in isolating memory protect problems.
</p>
<hr />
<p>
<a href="" id="Using-valgrind"></a> <a href="" id="Using-valgrind-1"></a>
</p>
<h4 id="using-valgrind" class="subsection">
4.3.2 Using valgrind
</h4>
<p>
If you have access to Linux on a common CPU type or supported versions of macOS<a href="concept-index.html#FOOT104" id="DOCF104"><sup>104</sup></a> you can use <code class="calibre2">valgrind</code> (<a href="http://www.valgrind.org/" class="uri">http://www.valgrind.org/</a>, pronounced to rhyme with ‘tinned’) to check for possible problems. To run some examples under <code class="calibre2">valgrind</code> use something like
</p>
<div class="example">
<pre class="example1"><code>R -d valgrind --vanilla &lt; mypkg-Ex.R
R -d &quot;valgrind --tool=memcheck --leak-check=full&quot; --vanilla &lt; mypkg-Ex.R</code></pre>
</div>
<p>
where mypkg-Ex.R is a set of examples, e.g. the file created in mypkg.Rcheck by <code class="calibre2">R CMD check</code>. Occasionally this reports memory reads of ‘uninitialised values’ that are the result of compiler optimization, so can be worth checking under an unoptimized compile: for maximal information use a build with debugging symbols. We know there will be some small memory leaks from <code class="calibre2">readline</code> and R itself — these are memory areas that are in use right up to the end of the R session. Expect this to run around 20x slower than without <code class="calibre2">valgrind</code>, and in some cases much slower than that. Several versions of <code class="calibre2">valgrind</code> were not happy with some optimized BLASes that use CPU-specific instructions so you may need to build a version of R specifically to use with <code class="calibre2">valgrind</code>.
</p>
<p>
On platforms where <code class="calibre2">valgrind</code> is installed you can build a version of R with extra instrumentation to help <code class="calibre2">valgrind</code> detect errors in the use of memory allocated from the R heap. The <code class="calibre2">configure</code> option is –with-valgrind-instrumentation=level, where level is 0, 1 or 2. Level 0 is the default and does not add anything. Level 1 will detect some uses<a href="concept-index.html#FOOT105" id="DOCF105"><sup>105</sup></a> of uninitialised memory and has little impact on speed (compared to level 0). Level 2 will detect many other memory-use bugs<a href="concept-index.html#FOOT106" id="DOCF106"><sup>106</sup></a> but make R much slower when running under <code class="calibre2">valgrind</code>. Using this in conjunction with <code class="calibre2">gctorture</code> can be even more effective (and even slower).
</p>
<p>
An example of <code class="calibre2">valgrind</code> output is
</p>
<div class="example">
<pre class="smallexample"><code>==12539== Invalid read of size 4
==12539==    at 0x1CDF6CBE: csc_compTr (Mutils.c:273)
==12539==    by 0x1CE07E1E: tsc_transpose (dtCMatrix.c:25)
==12539==    by 0x80A67A7: do_dotcall (dotcode.c:858)
==12539==    by 0x80CACE2: Rf_eval (eval.c:400)
==12539==    by 0x80CB5AF: R_execClosure (eval.c:658)
==12539==    by 0x80CB98E: R_execMethod (eval.c:760)
==12539==    by 0x1B93DEFA: R_standardGeneric (methods_list_dispatch.c:624)
==12539==    by 0x810262E: do_standardGeneric (objects.c:1012)
==12539==    by 0x80CAD23: Rf_eval (eval.c:403)
==12539==    by 0x80CB2F0: Rf_applyClosure (eval.c:573)
==12539==    by 0x80CADCC: Rf_eval (eval.c:414)
==12539==    by 0x80CAA03: Rf_eval (eval.c:362)
==12539==  Address 0x1C0D2EA8 is 280 bytes inside a block of size 1996 alloc&#39;d
==12539==    at 0x1B9008D1: malloc (vg_replace_malloc.c:149)
==12539==    by 0x80F1B34: GetNewPage (memory.c:610)
==12539==    by 0x80F7515: Rf_allocVector (memory.c:1915)
...</code></pre>
</div>
<p>
This example is from an instrumented version of R, while tracking down a bug in the <a href="https://CRAN.R-project.org/package=Matrix"><strong>Matrix</strong></a> package in 2006. The first line indicates that R has tried to read 4 bytes from a memory address that it does not have access to. This is followed by a C stack trace showing where the error occurred. Next is a description of the memory that was accessed. It is inside a block allocated by <code class="calibre2">malloc</code>, called from <code class="calibre2">GetNewPage</code>, that is, in the internal R heap. Since this memory all belongs to R, <code class="calibre2">valgrind</code> would not (and did not) detect the problem in an uninstrumented build of R. In this example the stack trace was enough to isolate and fix the bug, which was in <code class="calibre2">tsc_transpose</code>, and in this example running under <code class="calibre2">gctorture()</code> did not provide any additional information. When the stack trace is not sufficiently informative the option –db-attach=yes to <code class="calibre2">valgrind</code> may be helpful. This starts a post-mortem debugger (by default <code class="calibre2">gdb</code>) so that variables in the C code can be inspected (see <a href="debugging.html#Inspecting-R-objects">Inspecting R objects</a>).
</p>
<p>
<code class="calibre2">valgrind</code> is good at spotting the use of uninitialized values: use option –track-origins=yes to show where these originated from. What it cannot detect is the misuse of arrays allocated on the stack: this includes C automatic variables and some<a href="concept-index.html#FOOT107" id="DOCF107"><sup>107</sup></a> Fortran arrays.
</p>
<p>
It is possible to run all the examples, tests and vignettes covered by <code class="calibre2">R CMD check</code> under <code class="calibre2">valgrind</code> by using the option –use-valgrind. If you do this you will need to select the <code class="calibre2">valgrind</code> options some other way, for example by having a ~/.valgrindrc file containing
</p>
<div class="example">
<pre class="example1"><code>--leak-check=full
--track-origins=yes</code></pre>
</div>
<p>
or setting the environment variable <code class="calibre2">VALGRIND_OPTS</code>.
</p>
<p>
On macOS you may need to ensure that debugging symbols are made available (so <code class="calibre2">valgrind</code> reports line numbers in files). This can usually be done with the <code class="calibre2">valgrind</code> option –dsymutil=yes to ask for the symbols to be dumped when the .so file is loaded. This will not work where packages are installed into a system area (such as the R.framework) and can be slow. Installing packages with <code class="calibre2">R CMD INSTALL –dsym</code> installs the dumped symbols. (This can also be done by setting environment variable <code class="calibre2">PKG_MAKE_DSYM</code> to a non-empty value before the <code class="calibre2">INSTALL</code>.)
</p>
<p>
This section has described the use of <code class="calibre2">memtest</code>, the default (and most useful) of <code class="calibre2">valgrind</code>’s tools. There are others described in its documentation: <code class="calibre2">helgrind</code> can be useful for threaded programs.
</p>
<hr />
<p>
<a href="" id="Using-Address-Sanitizer"></a> <a href="" id="Using-the-Address-Sanitizer"></a>
</p>
<h4 id="using-the-address-sanitizer" class="subsection">
4.3.3 Using the Address Sanitizer
</h4>
<p>
<code class="calibre2">AddressSanitizer</code> (‘ASan’) is a tool with similar aims to the memory checker in <code class="calibre2">valgrind</code>. It is available with suitable builds<a href="concept-index.html#FOOT108" id="DOCF108"><sup>108</sup></a> of <code class="calibre2">gcc</code> and <code class="calibre2">clang</code> on common Linux and macOS platforms. See <a href="http://clang.llvm.org/docs/UsersManual.html#controlling-code-generation" class="uri">http://clang.llvm.org/docs/UsersManual.html#controlling-code-generation</a>, <a href="http://clang.llvm.org/docs/AddressSanitizer.html" class="uri">http://clang.llvm.org/docs/AddressSanitizer.html</a> and <a href="https://code.google.com/p/address-sanitizer/" class="uri">https://code.google.com/p/address-sanitizer/</a>.
</p>
<p>
More thorough checks of C++ code are done if the C++ library has been ‘annotated’: at the time of writing this applied to <code class="calibre2">std::vector</code> in <code class="calibre2">libc++</code> for use with <code class="calibre2">clang</code> and gives rise to ‘container-overflow’<a href="concept-index.html#FOOT109" id="DOCF109"><sup>109</sup></a> reports.
</p>
<p>
It requires code to have been compiled <em>and linked</em> with -fsanitize=address and compiling with <code class="calibre2">-fno-omit-frame-pointer</code> will give more legible reports. It has a runtime penalty of 2–3x, extended compilation times and uses substantially more memory, often 1–2GB, at run time. On 64-bit platforms it reserves (but does not allocate) 16–20TB of virtual memory: restrictive shell settings can cause problems.
</p>
<p>
By comparison with <code class="calibre2">valgrind</code>, ASan can detect misuse of stack and global variables but not the use of uninitialized memory.
</p>
<p>
Recent versions return symbolic addresses for the location of the error provided <code class="calibre2">llvm-symbolizer</code><a href="concept-index.html#FOOT110" id="DOCF110"><sup>110</sup></a> is on the path: if it is available but not on the path or has been renamed<a href="concept-index.html#FOOT111" id="DOCF111"><sup>111</sup></a>, one can use an environment variable, e.g.
</p>
<div class="example">
<pre class="example1"><code>ASAN_SYMBOLIZER_PATH=/path/to/llvm-symbolizer</code></pre>
</div>
<p>
An alternative is to pipe the output through <code class="calibre2">asan_symbolize.py</code><a href="concept-index.html#FOOT112" id="DOCF112"><sup>112</sup></a> and perhaps then (for compiled C++ code) <code class="calibre2">c++filt</code>. (On macOS, you may need to run <code class="calibre2">dsymutil</code> to get line-number reports.)
</p>
<p>
The simplest way to make use of this is to build a version of R with something like
</p>
<div class="example">
<pre class="example1"><code>CC=&quot;gcc -std=gnu99 -fsanitize=address&quot;
CFLAGS=&quot;-fno-omit-frame-pointer -g -O2 -Wall -pedantic -mtune=native&quot;</code></pre>
</div>
<p>
which will ensure that the <code class="calibre2">libasan</code> run-time library is compiled into the R executable. However this check can be enabled on a per-package basis by using a ~/.R/Makevars file like
</p>
<div class="example">
<pre class="example1"><code>CC = gcc -std=gnu99 -fsanitize=address -fno-omit-frame-pointer
CXX = g++ -fsanitize=address -fno-omit-frame-pointer
F77 = gfortran -fsanitize=address
FC = gfortran -fsanitize=address</code></pre>
</div>
<p>
(Note that <code class="calibre2">-fsanitize=address</code> has to be part of the compiler specification to ensure it is used for linking. These settings will not be honoured by packages which ignore ~/.R/Makevars.) It will be necessary to build R with
</p>
<div class="example">
<pre class="example1"><code>MAIN_LDFLAGS = -fsanitize=address</code></pre>
</div>
<p>
to link the runtime libraries into the R executable if it was not specified as part of ‘CC’ when R was built.
</p>
<p>
For options available <em>via</em> the environment variable <code class="calibre2">ASAN_OPTIONS</code> see <a href="https://code.google.com/p/address-sanitizer/wiki/AddressSanitizerFLags" class="uri">https://code.google.com/p/address-sanitizer/wiki/AddressSanitizerFLags</a>. With <code class="calibre2">gcc</code> additional control is available <em>via</em> the –param flag: see its <code class="calibre2">man</code> page.
</p>
<p>
For more detailed information on an error, R can be run under a debugger with a breakpoint set before the address sanitizer report is produced: for <code class="calibre2">gdb</code> or <code class="calibre2">lldb</code> you could use
</p>
<div class="example">
<pre class="example1"><code>break __asan_report_error</code></pre>
</div>
<p>
(See <a href="https://code.google.com/p/address-sanitizer/wiki/AddressSanitizer#gdb" class="uri">https://code.google.com/p/address-sanitizer/wiki/AddressSanitizer#gdb</a>.)
</p>
<p>
Recent versions<a href="concept-index.html#FOOT113" id="DOCF113"><sup>113</sup></a> added the flag -fsanitize-address-use-after-scope: see <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterScope" class="uri">https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterScope</a>.
</p>
<hr />
<p>
<a href="" id="Using-Leak-Sanitizer"></a> <a href="" id="Using-the-Leak-Sanitizer"></a>
</p>
<h4 id="using-the-leak-sanitizer" class="subsection">
4.3.3.1 Using the Leak Sanitizer
</h4>
<p>
For <code class="calibre2">x86_64</code> Linux there is a leak sanitizer, ‘LSan’: see <a href="https://code.google.com/p/address-sanitizer/wiki/LeakSanitizer" class="uri">https://code.google.com/p/address-sanitizer/wiki/LeakSanitizer</a>. This is available on recent versions of <code class="calibre2">gcc</code> and <code class="calibre2">clang</code>, and where available is compiled in as part of ASan.
</p>
<p>
One way to invoke this from an ASan-enabled build is by the environment variable
</p>
<div class="example">
<pre class="example1"><code>ASAN_OPTIONS=&#39;detect_leaks=1&#39;</code></pre>
</div>
<p>
However, this was made the default as from <code class="calibre2">clang</code> 3.5 and <code class="calibre2">gcc</code> 5.1.0.
</p>
<p>
When LSan is enabled, leaks give the process a failure error status (by default <code class="calibre2">23</code>). For an R package this means the R process, and as the parser retains some memory to the end of the process, if R itself was built against ASan, all runs will have a failure error status (which may include running R as part of building R itself).
</p>
<p>
To disable both this and some strict checking use
</p>
<div class="example">
<pre class="example1"><code>setenv ASAN_OPTIONS ‘alloc_dealloc_mismatch=0:detect_leaks=0:detect_odr_violation=0’</code></pre>
</div>
<p>
LSan also has a ‘stand-alone’ mode where it is compiled in using -fsanitize=leak and avoids the run-time overhead of ASan.
</p>
<hr />
<p>
<a href="" id="Using-Undefined-Behaviour-Sanitizer"></a> <a href="" id="Using-the-Undefined-Behaviour-Sanitizer"></a>
</p>
<h4 id="using-the-undefined-behaviour-sanitizer" class="subsection">
4.3.4 Using the Undefined Behaviour Sanitizer
</h4>
<p>
‘Undefined behaviour’ is where the language standard does not require particular behaviour from the compiler. Examples include division by zero (where for doubles R requires the ISO/IEC 60559 behaviour but C/C++ do not), use of zero-length arrays, shifts too far for signed types (e.g. <code class="calibre2">int x, y; y = x &lt;&lt; 31;</code>), out-of-range coercion, invalid C++ casts and mis-alignment. Not uncommon examples of out-of-range coercion in R packages are attempts to coerce a <code class="calibre2">NaN</code> or infinity to type <code class="calibre2">int</code> or <code class="calibre2">NA_INTEGER</code> to an unsigned type such as <code class="calibre2">size_t</code>. Also common is <code class="calibre2">y[x - 1]</code> forgetting that <code class="calibre2">x</code> might be <code class="calibre2">NA_INTEGER</code>.
</p>
<p>
‘UBSanitizer’ is a tool for C/C++ source code selected by -fsanitize=undefined in suitable builds<a href="concept-index.html#FOOT114" id="DOCF114"><sup>114</sup></a> of <code class="calibre2">clang</code> and GCC. Its (main) runtime library is linked into each package’s DLL, so it is less often needed to be included in <code class="calibre2">MAIN_LDFLAGS</code>.
</p>
<p>
This sanitizer can be combined with the Address Sanitizer by -fsanitize=undefined,address (where both are supported).
</p>
<p>
Finer control of what is checked can be achieved by other options: for <code class="calibre2">clang</code> see <a href="http://clang.llvm.org/docs/UsersManual.html#controlling-code-generation" class="uri">http://clang.llvm.org/docs/UsersManual.html#controlling-code-generation</a>.<a href="concept-index.html#FOOT115" id="DOCF115"><sup>115</sup></a> The current set for <code class="calibre2">clang</code> is (on a single line):
</p>
<div class="example">
<pre class="example1"><code>-fsanitize=alignment,bool,bounds,enum,float-cast-overflow,
float-divide-by-zero,function,integer-divide-by-zero,nonnull-attribute,
null,object-size,pointer-overflow,return,returns-nonnull-attribute,shift,
signed-integer-overflow,unreachable,unsigned-integer-overflow,vla-bound,vptr</code></pre>
</div>
<p>
(plus the more specific versions <code class="calibre2">shift-base</code> and <code class="calibre2">shift-exponent</code>) a subset of which could be combined with <code class="calibre2">address</code>, or use something like
</p>
<div class="example">
<pre class="example1"><code>-fsanitize=undefined -fno-sanitize=float-divide-by-zero</code></pre>
</div>
<p>
Options <code class="calibre2">function</code>, <code class="calibre2">return</code> and <code class="calibre2">vptr</code> apply only to C++: to use <code class="calibre2">vptr</code> its run-time library needs to be linked into the main R executable by building the latter with something like
</p>
<div class="example">
<pre class="example1"><code>MAIN_LD=&quot;clang++ -fsanitize=undefined&quot;</code></pre>
</div>
<p>
Option <code class="calibre2">float-divide-by-zero</code> is undesirable for use with R which allow such divisions as part of IEC 60559 arithmetic.
</p>
<p>
See <a href="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html" class="uri">https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html</a> (or the manual for your version of GCC, installed or <em>via</em> <a href="https://gcc.gnu.org/onlinedocs/" class="uri">https://gcc.gnu.org/onlinedocs/</a>: look for ‘Program Instrumentation Options’) for the options supported by GCC: 6 and 7 support
</p>
<div class="example">
<pre class="example1"><code>-fsanitize=alignment,bool,bounds,enum,integer-divide-by-zero,
nonnull-attribute,null,object-size, return,returns-nonnull-attribute,
shift,signed-integer-overflow,unreachable,vla-bound,vptr</code></pre>
</div>
<p>
plus the more specific versions <code class="calibre2">shift-base</code> and <code class="calibre2">shift-exponent</code> and non-default options
</p>
<div class="example">
<pre class="example1"><code>bound-strict,float-cast-overflow,float-divide-by-zero</code></pre>
</div>
<p>
where <code class="calibre2">float-divide-by-zero</code> is not desirable for R uses and <code class="calibre2">bounds-strict</code> is an extension of <code class="calibre2">bounds</code>.
</p>
<p>
From GCC 8 <code class="calibre2">signed-integer-overflow</code> will no longer be a default part of -fsanitize=undefined, but can be specified separately.
</p>
<p>
Other useful flags include
</p>
<div class="example">
<pre class="example1"><code>-no-fsanitize-recover</code></pre>
</div>
<p>
which causes the first report to be fatal (it always is for the <code class="calibre2">unreachable</code> and <code class="calibre2">return</code> suboptions). For more detailed information on where the runtime error occurs, R can be run under a debugger with a breakpoint set before the sanitizer report is produced: for <code class="calibre2">gdb</code> or <code class="calibre2">lldb</code> you could use
</p>
<div class="example">
<pre class="example1"><code>break __ubsan_handle_float_cast_overflow
break __ubsan_handle_float_cast_overflow_abort</code></pre>
</div>
<p>
or similar (there are handlers for each type of undefined behaviour).
</p>
<p>
There are also the compiler flags -fcatch-undefined-behavior and -ftrapv, said to be more reliable in <code class="calibre2">clang</code> than <code class="calibre2">gcc</code>.
</p>
<p>
For more details on the topic see <a href="http://blog.regehr.org/archives/213" class="uri">http://blog.regehr.org/archives/213</a> and <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html" class="uri">http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html</a> (which has 3 parts).
</p>
<hr />
<p>
<a href="" id="Other-analyses-with-_0060clang_0027"></a> <a href="" id="Other-analyses-with-_0060clang_0027-1"></a>
</p>
<h4 id="other-analyses-with-clang" class="subsection">
4.3.5 Other analyses with ‘clang’
</h4>
<p>
Recent versions of <code class="calibre2">clang</code> on ‘x86_64’ Linux have ‘ThreadSanitizer’ (<a href="https://code.google.com/p/thread-sanitizer/" class="uri">https://code.google.com/p/thread-sanitizer/</a>), a ‘data race detector for C/C++ programs’, and ‘MemorySanitizer’ (<a href="http://clang.llvm.org/docs/MemorySanitizer.html" class="uri">http://clang.llvm.org/docs/MemorySanitizer.html</a>, <a href="https://code.google.com/p/memory-sanitizer/wiki/MemorySanitizer" class="uri">https://code.google.com/p/memory-sanitizer/wiki/MemorySanitizer</a>) for the detection of uninitialized memory. Both are based on and provide similar functionality to tools in <code class="calibre2">valgrind</code>.
</p>
<p>
<code class="calibre2">clang</code> has a ‘Static Analyser’ which can be run on the source files during compilation: see <a href="http://clang-analyzer.llvm.org/" class="uri">http://clang-analyzer.llvm.org/</a>.
</p>
<hr />
<p>
<a href="" id="Using-_0060Dr_002e-Memory_0027"></a> <a href="" id="Using-_0060Dr_002e-Memory_0027-1"></a>
</p>
<h4 id="using-dr.-memory" class="subsection">
4.3.6 Using ‘Dr. Memory’
</h4>
<p>
‘Dr. Memory’ from <a href="http://www.drmemory.org/" class="uri">http://www.drmemory.org/</a> is a memory checker for (currently) 32-bit Windows, Linux and macOS with similar aims to <code class="calibre2">valgrind</code>. It works with unmodified executables<a href="concept-index.html#FOOT116" id="DOCF116"><sup>116</sup></a> and detects memory access errors, uninitialized reads and memory leaks.
</p>
<hr />
<p>
<a href="" id="Fortran-array-bounds-checking"></a> <a href="" id="Fortran-array-bounds-checking-1"></a>
</p>
<h4 id="fortran-array-bounds-checking" class="subsection">
4.3.7 Fortran array bounds checking
</h4>
<p>
Most of the Fortran compilers used with R allow code to be compiled with checking of array bounds: for example <code class="calibre2">gfortran</code> has option -fbounds-check and Oracle Studio has -C. This will give an error when the upper or lower bound is exceeded, e.g.
</p>
<div class="example">
<pre class="example1"><code>At line 97 of file .../src/appl/dqrdc2.f
Fortran runtime error: Index ‘1’ of dimension 1 of array ‘x’ above upper bound of 0</code></pre>
</div>
<p>
One does need to be aware that lazy programmers often specify Fortran dimensions as <code class="calibre2">1</code> rather than <code class="calibre2">*</code> or a real bound and these will be reported.
</p>
<p>
It is easy to arrange to use this check on just the code in your package: add to ~/.R/Makevars something like (for <code class="calibre2">gfortran</code>)
</p>
<div class="example">
<pre class="example1"><code>FCFLAGS = -g -O2 -mtune=native -fbounds-check
FFLAGS = -g -O2 -mtune=native -fbounds-check</code></pre>
</div>
<p>
when you run <code class="calibre2">R CMD check</code>.
</p>
<p>
This may report incorrectly errors with the way that Fortran character variables are passed, particularly when Fortran subroutines are called from C code. This may include the use of BLAS and LAPACK subroutines in R, so it is not advisable to build R itself with bounds checking (and may not even be possible as these subroutines are called during the R build).
</p>
<hr />
<p>
<a href="" id="Debugging-compiled-code"></a> <a href="" id="Debugging-compiled-code-1"></a>
</p>
<h3 id="debugging-compiled-code" class="section">
4.4 Debugging compiled code
</h3>
<p>
<a href="" id="index-Debugging"></a>
</p>
<p>
Sooner or later programmers will be faced with the need to debug compiled code loaded into R. This section is geared to platforms using <code class="calibre2">gdb</code> with code compiled by <code class="calibre2">gcc</code>, but similar things are possible with other debuggers such as <code class="calibre2">lldb</code> (<a href="http://lldb.llvm.org/" class="uri">http://lldb.llvm.org/</a>, used on macOS) and Sun’s <code class="calibre2">dbx</code>: some debuggers have graphical front-ends available.
</p>
<p>
Consider first ‘crashes’, that is when R terminated unexpectedly with an illegal memory access (a ‘segfault’ or ‘bus error’), illegal instruction or similar. Unix-alike versions of R use a signal handler which aims to give some basic information. For example
</p>
<div class="example">
<pre class="example1"><code> *** caught segfault ***
address 0x20000028, cause ‘memory not mapped’

Traceback:
 1: .identC(class1[[1]], class2)
 2: possibleExtends(class(sloti), classi, ClassDef2 = getClassDef(classi,
where = where))
 3: validObject(t(cu))
 4: stopifnot(validObject(cu &lt;- as(tu, &quot;dtCMatrix&quot;)), validObject(t(cu)),
validObject(t(tu)))

Possible actions:
1: abort (with core dump)
2: normal R exit
3: exit R without saving workspace
4: exit R saving workspace
Selection: 3</code></pre>
</div>
<p>
Since the R process may be damaged, the only really safe options are the first or third. (Note that a core dump is only produced where enabled: a common default in a shell is to limit its size to 0, thereby disabling it.)
</p>
<p>
A fairly common cause of such crashes is a package which uses <code class="calibre2">.C</code> or <code class="calibre2">.Fortran</code> and writes beyond (at either end) one of the arguments it is passed. There is a good way to detect this: using <code class="calibre2">options(CBoundsCheck = TRUE)</code> (which can be selected <em>via</em> the environment variable <code class="calibre2">R_C_BOUNDS_CHECK=yes)</code> changes the way <code class="calibre2">.C</code> and <code class="calibre2">.Fortran</code> work to check if the compiled code writes in the 64 bytes at either end of an argument.
</p>
<p>
Another cause of a ‘crash’ is to overrun the C stack. R tries to track that in its own code, but it may happen in third-party compiled code. For modern POSIX-compliant OSes R can safely catch that and return to the top-level prompt, so one gets something like
</p>
<div class="example">
<pre class="example1"><code>&gt; .C(&quot;aaa&quot;)
Error: segfault from C stack overflow
&gt;</code></pre>
</div>
<p>
However, C stack overflows are fatal under Windows and normally defeat attempts at debugging on that platform. Further, the size of the stack is set when R is compiled, whereas on POSIX OSes it can be set in the shell from which R is launched.
</p>
<p>
If you have a crash which gives a core dump you can use something like
</p>
<div class="example">
<pre class="example1"><code>gdb /path/to/R/bin/exec/R core.12345</code></pre>
</div>
<p>
to examine the core dump. If core dumps are disabled or to catch errors that do not generate a dump one can run R directly under a debugger by for example
</p>
<div class="example">
<pre class="example1"><code>$ R -d gdb --vanilla
...
gdb&gt; run</code></pre>
</div>
<p>
at which point R will run normally, and hopefully the debugger will catch the error and return to its prompt. This can also be used to catch infinite loops or interrupt very long-running code. For a simple example
</p>
<div class="example">
<pre class="example1"><code>&gt; for(i in 1:1e7) x &lt;- rnorm(100)
[hit Ctrl-C]
Program received signal SIGINT, Interrupt.
x00397682 in _int_free () from /lib/tls/libc.so.6
(gdb) where
#0  0x00397682 in _int_free () from /lib/tls/libc.so.6
#1  0x00397eba in free () from /lib/tls/libc.so.6
#2  0xb7cf2551 in R_gc_internal (size_needed=313)
    at /users/ripley/R/svn/R-devel/src/main/memory.c:743
#3  0xb7cf3617 in Rf_allocVector (type=13, length=626)
    at /users/ripley/R/svn/R-devel/src/main/memory.c:1906
#4  0xb7c3f6d3 in PutRNGstate ()
    at /users/ripley/R/svn/R-devel/src/main/RNG.c:351
#5  0xb7d6c0a5 in do_random2 (call=0x94bf7d4, op=0x92580e8, args=0x9698f98,
    rho=0x9698f28) at /users/ripley/R/svn/R-devel/src/main/random.c:183
...</code></pre>
</div>
<p>
In many cases it is possible to attach a debugger to a running process: this is helpful if an alternative front-end is in use or to investigate a task that seems to be taking far too long. This is done by something like
</p>
<div class="example">
<pre class="example1"><code>gdb -p pid</code></pre>
</div>
<p>
where <code class="calibre2">pid</code> is the id of the R executable or front-end. This stops the process so its state can be examined: use <code class="calibre2">continue</code> to resume execution.
</p>
<p>
Some “tricks” worth knowing follow:
</p>
<hr />
<p>
<a href="" id="Finding-entry-points"></a> <a href="" id="Finding-entry-points-in-dynamically-loaded-code"></a>
</p>
<h4 id="finding-entry-points-in-dynamically-loaded-code" class="subsection">
4.4.1 Finding entry points in dynamically loaded code
</h4>
<p>
Under most compilation environments, compiled code dynamically loaded into R cannot have breakpoints set within it until it is loaded. To use a symbolic debugger on such dynamically loaded code under Unix-alikes use
</p>
<ul>
<li>
Call the debugger on the R executable, for example by R -d gdb.
</li>
<li>
Start R.
</li>
<li>
At the R prompt, use <code class="calibre2">dyn.load</code> or <code class="calibre2">library</code> to load your shared object.
</li>
<li>
Send an interrupt signal. This will put you back to the debugger prompt.
</li>
<li>
Set the breakpoints in your code.
</li>
<li>
Continue execution of R by typing signal 0<span>RET</span>.
</li>
</ul>
<p>
Under Windows signals may not be able to be used, and if so the procedure is more complicated. See the rw-FAQ and <a href="http://www.stats.uwo.ca/faculty/murdoch/software/debuggingR/gdb.shtml"><code class="calibre2">www.stats.uwo.ca/faculty/murdoch/software/debuggingR/gdb.shtml</code></a>.
</p>
<hr />
<p>
<a href="" id="Inspecting-R-objects"></a> <a href="" id="Inspecting-R-objects-when-debugging"></a>
</p>
<h4 id="inspecting-r-objects-when-debugging" class="subsection">
4.4.2 Inspecting R objects when debugging
</h4>
<p>
<a href="" id="index-Inspecting-R-objects-when-debugging"></a>
</p>
<p>
The key to inspecting R objects from compiled code is the function <code class="calibre2">PrintValue(SEXP s)</code> which uses the normal R printing mechanisms to print the R object pointed to by s, or the safer version <code class="calibre2">R_PV(SEXP s)</code> which will only print ‘objects’.
</p>
<p>
One way to make use of <code class="calibre2">PrintValue</code> is to insert suitable calls into the code to be debugged.
</p>
<p>
Another way is to call <code class="calibre2">R_PV</code> from the symbolic debugger. (<code class="calibre2">PrintValue</code> is hidden as <code class="calibre2">Rf_PrintValue</code>.) For example, from <code class="calibre2">gdb</code> we can use
</p>
<div class="example">
<pre class="example1"><code>(gdb) p R_PV(ab)</code></pre>
</div>
<p>
using the object <code class="calibre2">ab</code> from the convolution example, if we have placed a suitable breakpoint in the convolution C code.
</p>
<p>
To examine an arbitrary R object we need to work a little harder. For example, let
</p>
<div class="example">
<pre class="example1"><code>R&gt; DF &lt;- data.frame(a = 1:3, b = 4:6)</code></pre>
</div>
<p>
By setting a breakpoint at <code class="calibre2">do_get</code> and typing get(“DF”) at the R prompt, one can find out the address in memory of <code class="calibre2">DF</code>, for example
</p>
<div class="example">
<pre class="example1"><code>Value returned is $1 = (SEXPREC *) 0x40583e1c
(gdb) p *$1
$2 = {
  sxpinfo = {type = 19, obj = 1, named = 1, gp = 0,
    mark = 0, debug = 0, trace = 0, = 0},
  attrib = 0x40583e80,
  u = {
    vecsxp = {
      length = 2,
      type = {c = 0x40634700 &quot;0&gt;X@D&gt;X@0&gt;X@&quot;, i = 0x40634700,
        f = 0x40634700, z = 0x40634700, s = 0x40634700},
      truelength = 1075851272,
    },
    primsxp = {offset = 2},
    symsxp = {pname = 0x2, value = 0x40634700, internal = 0x40203008},
    listsxp = {carval = 0x2, cdrval = 0x40634700, tagval = 0x40203008},
    envsxp = {frame = 0x2, enclos = 0x40634700},
    closxp = {formals = 0x2, body = 0x40634700, env = 0x40203008},
    promsxp = {value = 0x2, expr = 0x40634700, env = 0x40203008}
  }
}</code></pre>
</div>
<p>
(Debugger output reformatted for better legibility).
</p>
<p>
Using <code class="calibre2">R_PV()</code> one can “inspect” the values of the various elements of the SEXP, for example,
</p>
<div class="example">
<pre class="example1"><code>(gdb) p R_PV($1-&gt;attrib)
$names
[1] &quot;a&quot; &quot;b&quot;

$row.names
[1] &quot;1&quot; &quot;2&quot; &quot;3&quot;

$class
[1] &quot;data.frame&quot;

$3 = void</code></pre>
</div>
<p>
To find out where exactly the corresponding information is stored, one needs to go “deeper”:
</p>
<div class="example">
<pre class="example1"><code>(gdb) set $a = $1-&gt;attrib
(gdb) p $a-&gt;u.listsxp.tagval-&gt;u.symsxp.pname-&gt;u.vecsxp.type.c
$4 = 0x405d40e8 &quot;names&quot;
(gdb) p $a-&gt;u.listsxp.carval-&gt;u.vecsxp.type.s[1]-&gt;u.vecsxp.type.c
$5 = 0x40634378 &quot;b&quot;
(gdb) p $1-&gt;u.vecsxp.type.s[0]-&gt;u.vecsxp.type.i[0]
$6 = 1
(gdb) p $1-&gt;u.vecsxp.type.s[1]-&gt;u.vecsxp.type.i[1]
$7 = 5</code></pre>
</div>
<p>
Another alternative is the <code class="calibre2">R_inspect</code> function which shows the low-level structure of the objects recursively (addresses differ from the above as this example is created on another machine):
</p>
<div class="example">
<pre class="example1"><code>(gdb) p R_inspect($1)
@100954d18 19 VECSXP g0c2 [OBJ,NAM(2),ATT] (len=2, tl=0)
  @100954d50 13 INTSXP g0c2 [NAM(2)] (len=3, tl=0) 1,2,3
  @100954d88 13 INTSXP g0c2 [NAM(2)] (len=3, tl=0) 4,5,6
ATTRIB:
  @102a70140 02 LISTSXP g0c0 []
    TAG: @10083c478 01 SYMSXP g0c0 [MARK,NAM(2),gp=0x4000] &quot;names&quot;
    @100954dc0 16 STRSXP g0c2 [NAM(2)] (len=2, tl=0)
      @10099df28 09 CHARSXP g0c1 [MARK,gp=0x21] &quot;a&quot;
      @10095e518 09 CHARSXP g0c1 [MARK,gp=0x21] &quot;b&quot;
    TAG: @100859e60 01 SYMSXP g0c0 [MARK,NAM(2),gp=0x4000] &quot;row.names&quot;
    @102a6f868 13 INTSXP g0c1 [NAM(2)] (len=2, tl=1) -2147483648,-3
    TAG: @10083c948 01 SYMSXP g0c0 [MARK,gp=0x4000] &quot;class&quot;
    @102a6f838 16 STRSXP g0c1 [NAM(2)] (len=1, tl=1)
      @1008c6d48 09 CHARSXP g0c2 [MARK,gp=0x21,ATT] &quot;data.frame&quot;</code></pre>
</div>
<p>
In general the representation of each object follows the format:
</p>
<div class="example">
<pre class="smallexample"><code>@&lt;address&gt; &lt;type-nr&gt; &lt;type-name&gt; &lt;gc-info&gt; [&lt;flags&gt;] ...</code></pre>
</div>
<p>
For a more fine-grained control over the depth of the recursion and the output of vectors <code class="calibre2">R_inspect3</code> takes additional two character() parameters: maximum depth and the maximal number of elements that will be printed for scalar vectors. The defaults in <code class="calibre2">R_inspect</code> are currently -1 (no limit) and 5 respectively.
</p>
<hr />
<p>
<a href="" id="System-and-foreign-language-interfaces"></a> <a href="" id="System-and-foreign-language-interfaces-1"></a>
</p>
<div id="calibre_pb_12" class="calibre6">

</div>

</div>
            </section>

          </div>
        </div>
      </div>
<a href="tidying-and-profiling-r-code.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="system-and-foreign-language-interfaces.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
